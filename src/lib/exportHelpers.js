// lib/exportHelpers.js - Export utility functions for TBM

import { formatExportMetadata, formatDate } from './formatters.js';

/**
 * Generate PDF export data
 * @param {object} book - Book object to export
 * @returns {object} - PDF export configuration
 */
export function generatePDFExport(book) {
  if (!book) throw new Error('Book data is required for PDF export');
  
  const metadata = formatExportMetadata(book, 'pdf');
  
  return {
    document: {
      info: {
        title: metadata.title,
        author: metadata.author,
        subject: metadata.subject,
        creator: 'Textbook Machine',
        producer: 'TBM PDF Generator',
        creationDate: new Date(),
        modDate: new Date()
      },
      pageSize: 'A4',
      margins: {
        top: 50,
        bottom: 50,
        left: 40,
        right: 40
      },
      fonts: {
        heading: 'Times-Bold',
        body: 'Times-Roman',
        code: 'Courier'
      }
    },
    content: generatePDFContent(book),
    styles: generatePDFStyles(),
    metadata
  };
}

/**
 * Generate DOCX export data
 * @param {object} book - Book object to export
 * @returns {object} - DOCX export configuration
 */
export function generateDOCXExport(book) {
  if (!book) throw new Error('Book data is required for DOCX export');
  
  const metadata = formatExportMetadata(book, 'docx');
  
  return {
    document: {
      creator: metadata.author,
      title: metadata.title,
      subject: metadata.subject,
      description: `Generated by Textbook Machine on ${metadata.exportDate}`,
      lastModifiedBy: 'Textbook Machine',
      revision: metadata.version
    },
    sections: generateDOCXSections(book),
    styles: generateDOCXStyles(),
    numbering: generateDOCXNumbering(),
    metadata
  };
}

/**
 * Generate EPUB export data
 * @param {object} book - Book object to export
 * @returns {object} - EPUB export configuration
 */
export function generateEPUBExport(book) {
  if (!book) throw new Error('Book data is required for EPUB export');
  
  const metadata = formatExportMetadata(book, 'epub');
  
  return {
    metadata: {
      title: metadata.title,
      author: metadata.author,
      publisher: 'Textbook Machine',
      language: metadata.language.toLowerCase(),
      pubdate: metadata.exportDate,
      description: `${metadata.subject} textbook for ${metadata.grade}`,
      rights: 'Generated by Textbook Machine'
    },
    chapters: generateEPUBChapters(book),
    css: generateEPUBStyles(),
    images: extractBookImages(book),
    toc: generateTableOfContents(book.chapters)
  };
}

/**
 * Generate HTML export data
 * @param {object} book - Book object to export
 * @returns {object} - HTML export configuration
 */
export function generateHTMLExport(book) {
  if (!book) throw new Error('Book data is required for HTML export');
  
  const metadata = formatExportMetadata(book, 'html');
  
  return {
    html: generateHTMLStructure(book),
    css: generateHTMLStyles(),
    js: generateHTMLScripts(),
    assets: extractBookAssets(book),
    metadata
  };
}

/**
 * Generate PDF content structure
 * @param {object} book - Book object
 * @returns {Array} - PDF content array
 */
function generatePDFContent(book) {
  const content = [];
  
  // Cover page
  content.push({
    type: 'cover',
    title: book.title,
    subtitle: book.subtitle || '',
    author: book.author || 'Textbook Machine',
    subject: book.subject || '',
    grade: book.grade || '',
    date: formatDate(new Date(), 'long')
  });
  
  // Table of contents
  content.push({
    type: 'toc',
    title: 'Table of Contents',
    chapters: book.chapters?.map((chapter, index) => ({
      number: index + 1,
      title: chapter.title,
      page: (index * 10) + 3 // Estimated page numbers
    })) || []
  });
  
  // Chapters
  book.chapters?.forEach((chapter, index) => {
    content.push({
      type: 'chapter',
      number: index + 1,
      title: chapter.title,
      content: chapter.content || '',
      summary: chapter.summary || '',
      questions: chapter.questions || [],
      references: chapter.references || []
    });
  });
  
  return content;
}

/**
 * Generate PDF styles
 * @returns {object} - PDF style definitions
 */
function generatePDFStyles() {
  return {
    title: {
      fontSize: 24,
      bold: true,
      alignment: 'center',
      margin: [0, 20, 0, 20]
    },
    subtitle: {
      fontSize: 16,
      alignment: 'center',
      margin: [0, 0, 0, 20],
      color: '#666666'
    },
    chapterTitle: {
      fontSize: 20,
      bold: true,
      margin: [0, 20, 0, 10],
      pageBreak: 'before'
    },
    sectionTitle: {
      fontSize: 16,
      bold: true,
      margin: [0, 15, 0, 8]
    },
    body: {
      fontSize: 12,
      lineHeight: 1.4,
      margin: [0, 0, 0, 8]
    },
    code: {
      fontSize: 10,
      font: 'Courier',
      background: '#f5f5f5',
      margin: [10, 5, 10, 5]
    },
    quote: {
      fontSize: 11,
      italics: true,
      margin: [20, 5, 20, 5],
      color: '#555555'
    },
    list: {
      fontSize: 12,
      margin: [20, 2, 0, 2]
    },
    header: {
      fontSize: 10,
      margin: [0, 0, 0, 0],
      alignment: 'center'
    },
    footer: {
      fontSize: 10,
      margin: [0, 0, 0, 0],
      alignment: 'center'
    }
  };
}

/**
 * Generate DOCX sections
 * @param {object} book - Book object
 * @returns {Array} - DOCX sections
 */
function generateDOCXSections(book) {
  const sections = [];
  
  // Cover section
  sections.push({
    properties: {
      page: {
        margin: { top: 1440, right: 1440, bottom: 1440, left: 1440 }
      }
    },
    children: [
      {
        type: 'paragraph',
        text: book.title,
        style: 'Title'
      },
      {
        type: 'paragraph',
        text: book.subtitle || '',
        style: 'Subtitle'
      },
      {
        type: 'paragraph',
        text: `By ${book.author || 'Textbook Machine'}`,
        style: 'Author'
      }
    ]
  });
  
  // Table of contents section
  sections.push({
    properties: {
      titlePage: false
    },
    children: [
      {
        type: 'tableOfContents',
        heading: 'Table of Contents'
      }
    ]
  });
  
  // Chapter sections
  book.chapters?.forEach((chapter, index) => {
    sections.push({
      properties: {
        page: {
          pageNumbers: {
            start: 1,
            formatType: 'decimal'
          }
        }
      },
      children: generateDOCXChapterContent(chapter, index + 1)
    });
  });
  
  return sections;
}

/**
 * Generate DOCX chapter content
 * @param {object} chapter - Chapter object
 * @param {number} chapterNumber - Chapter number
 * @returns {Array} - Chapter content
 */
function generateDOCXChapterContent(chapter, chapterNumber) {
  const content = [];
  
  // Chapter title
  content.push({
    type: 'paragraph',
    text: `Chapter ${chapterNumber}: ${chapter.title}`,
    style: 'Heading1'
  });
  
  // Chapter description
  if (chapter.description) {
    content.push({
      type: 'paragraph',
      text: chapter.description,
      style: 'Normal'
    });
  }
  
  // Chapter content
  if (chapter.content) {
    const paragraphs = chapter.content.split('\n\n');
    paragraphs.forEach(paragraph => {
      if (paragraph.trim()) {
        content.push({
          type: 'paragraph',
          text: paragraph.trim(),
          style: 'Normal'
        });
      }
    });
  }
  
  // Chapter summary
  if (chapter.summary) {
    content.push({
      type: 'paragraph',
      text: 'Summary',
      style: 'Heading2'
    });
    content.push({
      type: 'paragraph',
      text: chapter.summary,
      style: 'Summary'
    });
  }
  
  // Practice questions
  if (chapter.questions && chapter.questions.length > 0) {
    content.push({
      type: 'paragraph',
      text: 'Practice Questions',
      style: 'Heading2'
    });
    
    chapter.questions.forEach((question, index) => {
      content.push({
        type: 'paragraph',
        text: `${index + 1}. ${question}`,
        style: 'ListParagraph'
      });
    });
  }
  
  return content;
}

/**
 * Generate DOCX styles
 * @returns {object} - DOCX style definitions
 */
function generateDOCXStyles() {
  return {
    default: {
      document: {
        run: {
          font: 'Times New Roman',
          size: 24 // 12pt
        },
        paragraph: {
          spacing: {
            line: 276, // 1.15 line spacing
            after: 200
          }
        }
      }
    },
    styles: [
      {
        id: 'Title',
        name: 'Title',
        run: {
          size: 56, // 28pt
          bold: true,
          color: '2F5496'
        },
        paragraph: {
          alignment: 'center',
          spacing: { after: 400 }
        }
      },
      {
        id: 'Subtitle',
        name: 'Subtitle',
        run: {
          size: 32, // 16pt
          color: '5B5B5B'
        },
        paragraph: {
          alignment: 'center',
          spacing: { after: 200 }
        }
      },
      {
        id: 'Heading1',
        name: 'Heading 1',
        run: {
          size: 36, // 18pt
          bold: true,
          color: '2F5496'
        },
        paragraph: {
          spacing: { before: 400, after: 200 }
        }
      },
      {
        id: 'Heading2',
        name: 'Heading 2',
        run: {
          size: 28, // 14pt
          bold: true,
          color: '2F5496'
        },
        paragraph: {
          spacing: { before: 300, after: 150 }
        }
      },
      {
        id: 'Normal',
        name: 'Normal',
        run: {
          size: 24 // 12pt
        },
        paragraph: {
          spacing: { after: 200 }
        }
      },
      {
        id: 'Summary',
        name: 'Summary',
        run: {
          size: 22, // 11pt
          italics: true
        },
        paragraph: {
          spacing: { after: 200 },
          border: {
            top: { style: 'single', size: 6, color: 'auto' }
          }
        }
      }
    ]
  };
}

/**
 * Generate DOCX numbering
 * @returns {object} - DOCX numbering configuration
 */
function generateDOCXNumbering() {
  return {
    config: [
      {
        reference: 'default-numbering',
        levels: [
          {
            level: 0,
            format: 'decimal',
            text: '%1.',
            alignment: 'left',
            style: {
              paragraph: {
                indent: { left: 720, hanging: 360 }
              }
            }
          }
        ]
      }
    ]
  };
}

/**
 * Generate EPUB chapters
 * @param {object} book - Book object
 * @returns {Array} - EPUB chapters
 */
function generateEPUBChapters(book) {
  const chapters = [];
  
  // Title page
  chapters.push({
    title: 'Title Page',
    filename: 'title.xhtml',
    content: `
      <h1>${book.title}</h1>
      <h2>${book.subtitle || ''}</h2>
      <p class="author">By ${book.author || 'Textbook Machine'}</p>
      <p class="date">${formatDate(new Date(), 'long')}</p>
    `
  });
  
  // Table of contents
  chapters.push({
    title: 'Table of Contents',
    filename: 'toc.xhtml',
    content: generateEPUBTOC(book.chapters)
  });
  
  // Book chapters
  book.chapters?.forEach((chapter, index) => {
    chapters.push({
      title: chapter.title,
      filename: `chapter${index + 1}.xhtml`,
      content: generateEPUBChapterHTML(chapter, index + 1)
    });
  });
  
  return chapters;
}

/**
 * Generate EPUB table of contents HTML
 * @param {Array} chapters - Chapter array
 * @returns {string} - TOC HTML
 */
function generateEPUBTOC(chapters) {
  if (!chapters || chapters.length === 0) return '<h1>Table of Contents</h1><p>No chapters available.</p>';
  
  let html = '<h1>Table of Contents</h1><ol class="toc">';
  
  chapters.forEach((chapter, index) => {
    html += `<li><a href="chapter${index + 1}.xhtml">${chapter.title}</a></li>`;
  });
  
  html += '</ol>';
  return html;
}

/**
 * Generate EPUB chapter HTML
 * @param {object} chapter - Chapter object
 * @param {number} chapterNumber - Chapter number
 * @returns {string} - Chapter HTML
 */
function generateEPUBChapterHTML(chapter, chapterNumber) {
  let html = `<h1>Chapter ${chapterNumber}: ${chapter.title}</h1>`;
  
  if (chapter.description) {
    html += `<p class="description">${chapter.description}</p>`;
  }
  
  if (chapter.content) {
    // Convert basic markdown-like formatting to HTML
    const content = chapter.content
      .replace(/\n\n/g, '</p><p>')
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>');
    
    html += `<div class="content"><p>${content}</p></div>`;
  }
  
  if (chapter.summary) {
    html += `<div class="summary"><h2>Summary</h2><p>${chapter.summary}</p></div>`;
  }
  
  if (chapter.questions && chapter.questions.length > 0) {
    html += '<div class="questions"><h2>Practice Questions</h2><ol>';
    chapter.questions.forEach(question => {
      html += `<li>${question}</li>`;
    });
    html += '</ol></div>';
  }
  
  return html;
}

/**
 * Generate EPUB styles
 * @returns {string} - CSS styles for EPUB
 */
function generateEPUBStyles() {
  return `
    body {
      font-family: Georgia, serif;
      line-height: 1.6;
      margin: 0;
      padding: 1em;
      color: #333;
    }
    
    h1 {
      color: #2c3e50;
      border-bottom: 2px solid #3498db;
      padding-bottom: 0.5em;
      margin-bottom: 1em;
    }
    
    h2 {
      color: #34495e;
      margin-top: 2em;
      margin-bottom: 1em;
    }
    
    p {
      margin-bottom: 1em;
      text-align: justify;
    }
    
    .author {
      font-style: italic;
      text-align: center;
      margin: 2em 0;
    }
    
    .date {
      text-align: center;
      color: #7f8c8d;
    }
    
    .description {
      font-style: italic;
      color: #555;
      border-left: 4px solid #3498db;
      padding-left: 1em;
      margin: 1.5em 0;
    }
    
    .summary {
      background-color: #ecf0f1;
      padding: 1em;
      border-radius: 5px;
      margin: 2em 0;
    }
    
    .questions {
      margin-top: 3em;
      padding-top: 2em;
      border-top: 1px solid #bdc3c7;
    }
    
    .toc {
      list-style-type: none;
      padding: 0;
    }
    
    .toc li {
      margin: 0.5em 0;
      padding: 0.5em;
      border-bottom: 1px dotted #bdc3c7;
    }
    
    .toc a {
      text-decoration: none;
      color: #2980b9;
    }
    
    .toc a:hover {
      text-decoration: underline;
    }
    
    code {
      background-color: #f8f9fa;
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
    }
    
    blockquote {
      border-left: 4px solid #95a5a6;
      padding-left: 1em;
      margin: 1.5em 0;
      font-style: italic;
      color: #555;
    }
  `;
}

/**
 * Generate HTML structure
 * @param {object} book - Book object
 * @returns {string} - Complete HTML document
 */
function generateHTMLStructure(book) {
  const metadata = formatExportMetadata(book, 'html');
  
  return `
    <!DOCTYPE html>
    <html lang="${metadata.language.toLowerCase()}">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>${metadata.title}</title>
      <meta name="author" content="${metadata.author}">
      <meta name="description" content="${book.subtitle || ''}">
      <meta name="generator" content="Textbook Machine">
      <link rel="stylesheet" href="styles.css">
    </head>
    <body>
      <header>
        <h1>${book.title}</h1>
        <h2>${book.subtitle || ''}</h2>
        <p class="author">By ${metadata.author}</p>
      </header>
      
      <nav id="table-of-contents">
        <h3>Table of Contents</h3>
        ${generateHTMLTOC(book.chapters)}
      </nav>
      
      <main>
        ${generateHTMLChapters(book.chapters)}
      </main>
      
      <footer>
        <p>Generated by Textbook Machine on ${metadata.exportDate}</p>
      </footer>
      
      <script src="scripts.js"></script>
    </body>
    </html>
  `;
}

/**
 * Generate HTML table of contents
 * @param {Array} chapters - Chapter array
 * @returns {string} - TOC HTML
 */
function generateHTMLTOC(chapters) {
  if (!chapters || chapters.length === 0) return '<p>No chapters available.</p>';
  
  let html = '<ol class="toc">';
  chapters.forEach((chapter, index) => {
    html += `<li><a href="#chapter-${index + 1}">${chapter.title}</a></li>`;
  });
  html += '</ol>';
  
  return html;
}

/**
 * Generate HTML chapters
 * @param {Array} chapters - Chapter array
 * @returns {string} - Chapters HTML
 */
function generateHTMLChapters(chapters) {
  if (!chapters || chapters.length === 0) return '<p>No chapters available.</p>';
  
  return chapters.map((chapter, index) => `
    <section id="chapter-${index + 1}" class="chapter">
      <h2>Chapter ${index + 1}: ${chapter.title}</h2>
      ${chapter.description ? `<p class="description">${chapter.description}</p>` : ''}
      ${chapter.content ? `<div class="content">${formatHTMLContent(chapter.content)}</div>` : ''}
      ${chapter.summary ? `<div class="summary"><h3>Summary</h3><p>${chapter.summary}</p></div>` : ''}
      ${chapter.questions ? generateHTMLQuestions(chapter.questions) : ''}
    </section>
  `).join('\n');
}

/**
 * Format HTML content
 * @param {string} content - Raw content
 * @returns {string} - Formatted HTML content
 */
function formatHTMLContent(content) {
  return content
    .split('\n\n')
    .map(paragraph => `<p>${paragraph.trim()}</p>`)
    .join('\n');
}

/**
 * Generate HTML questions section
 * @param {Array} questions - Questions array
 * @returns {string} - Questions HTML
 */
function generateHTMLQuestions(questions) {
  if (!questions || questions.length === 0) return '';
  
  let html = '<div class="questions"><h3>Practice Questions</h3><ol>';
  questions.forEach(question => {
    html += `<li>${question}</li>`;
  });
  html += '</ol></div>';
  
  return html;
}

/**
 * Generate HTML styles
 * @returns {string} - CSS styles for HTML export
 */
function generateHTMLStyles() {
  return `
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Georgia, serif;
      line-height: 1.6;
      color: #333;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background-color: #fafafa;
    }
    
    header {
      text-align: center;
      margin-bottom: 3rem;
      padding-bottom: 2rem;
      border-bottom: 2px solid #3498db;
    }
    
    header h1 {
      font-size: 2.5rem;
      color: #2c3e50;
      margin-bottom: 0.5rem;
    }
    
    header h2 {
      font-size: 1.5rem;
      color: #7f8c8d;
      font-weight: normal;
      margin-bottom: 1rem;
    }
    
    .author {
      font-style: italic;
      color: #555;
    }
    
    nav {
      background-color: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
    }
    
    nav h3 {
      color: #2c3e50;
      margin-bottom: 1rem;
    }
    
    .toc {
      list-style: none;
    }
    
    .toc li {
      margin: 0.5rem 0;
      padding: 0.5rem;
      border-bottom: 1px dotted #bdc3c7;
    }
    
    .toc a {
      text-decoration: none;
      color: #2980b9;
      font-weight: 500;
    }
    
    .toc a:hover {
      text-decoration: underline;
    }
    
    .chapter {
      background-color: white;
      padding: 2rem;
      margin-bottom: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    
    .chapter h2 {
      color: #2c3e50;
      margin-bottom: 1.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #3498db;
    }
    
    .description {
      font-style: italic;
      color: #555;
      background-color: #ecf0f1;
      padding: 1rem;
      border-left: 4px solid #3498db;
      margin: 1.5rem 0;
    }
    
    .content p {
      margin-bottom: 1rem;
      text-align: justify;
    }
    
    .summary {
      background-color: #e8f6f3;
      padding: 1.5rem;
      border-radius: 5px;
      margin: 2rem 0;
      border-left: 4px solid #27ae60;
    }
    
    .summary h3 {
      color: #27ae60;
      margin-bottom: 1rem;
    }
    
    .questions {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 1px solid #bdc3c7;
    }
    
    .questions h3 {
      color: #e74c3c;
      margin-bottom: 1rem;
    }
    
    .questions ol {
      padding-left: 1.5rem;
    }
    
    .questions li {
      margin-bottom: 0.5rem;
    }
    
    footer {
      text-align: center;
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 1px solid #bdc3c7;
      color: #7f8c8d;
      font-size: 0.9rem;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }
      
      header h1 {
        font-size: 2rem;
      }
      
      .chapter {
        padding: 1.5rem;
      }
    }
    
    @media print {
      body {
        background-color: white;
        max-width: none;
      }
      
      .chapter {
        box-shadow: none;
        border: 1px solid #ddd;
      }
      
      nav {
        box-shadow: none;
        border: 1px solid #ddd;
      }
    }
  `;
}

/**
 * Generate HTML scripts
 * @returns {string} - JavaScript for HTML export
 */
function generateHTMLScripts() {
  return `
    // Smooth scrolling for TOC links
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
          target.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });
        }
      });
    });
    
    // Add print functionality
    function printBook() {
      window.print();
    }
    
    // Add bookmark functionality
    function bookmarkPage() {
      if (navigator.share) {
        navigator.share({
          title: document.title,
          url: window.location.href
        });
      } else {
        // Fallback: copy URL to clipboard
        navigator.clipboard.writeText(window.location.href).then(() => {
          alert('URL copied to clipboard!');
        });
      }
    }
    
    // Highlight current section in TOC
    function highlightCurrentSection() {
      const sections = document.querySelectorAll('.chapter');
      const tocLinks = document.querySelectorAll('.toc a');
      
      let current = '';
      sections.forEach(section => {
        const sectionTop = section.offsetTop;
        if (pageYOffset >= sectionTop - 60) {
          current = section.getAttribute('id');
        }
      });
      
      tocLinks.forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('href') === '#' + current) {
          link.classList.add('active');
        }
      });
    }
    
    window.addEventListener('scroll', highlightCurrentSection);
    
    // Add search functionality
    function searchContent(query) {
      const content = document.querySelector('main');
      const text = content.textContent.toLowerCase();
      const searchQuery = query.toLowerCase();
      
      if (searchQuery && text.includes(searchQuery)) {
        // Simple search highlight (could be enhanced)
        const regex = new RegExp(searchQuery, 'gi');
        content.innerHTML = content.innerHTML.replace(regex, '<mark>$&</mark>');
      }
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
      highlightCurrentSection();
      console.log('Textbook Machine HTML export loaded successfully');
    });
  `;
}

/**
 * Extract images from book content
 * @param {object} book - Book object
 * @returns {Array} - Array of image references
 */
function extractBookImages(book) {
  const images = [];
  
  book.chapters?.forEach(chapter => {
    if (chapter.content) {
      const imgRegex = /<img[^>]+src="([^"]+)"[^>]*>/gi;
      let match;
      while ((match = imgRegex.exec(chapter.content)) !== null) {
        images.push({
          src: match[1],
          chapter: chapter.title,
          filename: match[1].split('/').pop()
        });
      }
    }
  });
  
  return images;
}

/**
 * Extract all assets from book content
 * @param {object} book - Book object
 * @returns {object} - Object containing all assets
 */
function extractBookAssets(book) {
  const assets = {
    images: [],
    videos: [],
    audio: [],
    documents: []
  };
  
  book.chapters?.forEach(chapter => {
    if (chapter.content) {
      // Extract images
      const imgRegex = /<img[^>]+src="([^"]+)"[^>]*>/gi;
      let match;
      while ((match = imgRegex.exec(chapter.content)) !== null) {
        assets.images.push({
          src: match[1],
          chapter: chapter.title,
          filename: match[1].split('/').pop()
        });
      }
      
      // Extract videos
      const videoRegex = /<video[^>]+src="([^"]+)"[^>]*>/gi;
      while ((match = videoRegex.exec(chapter.content)) !== null) {
        assets.videos.push({
          src: match[1],
          chapter: chapter.title,
          filename: match[1].split('/').pop()
        });
      }
      
      // Extract audio
      const audioRegex = /<audio[^>]+src="([^"]+)"[^>]*>/gi;
      while ((match = audioRegex.exec(chapter.content)) !== null) {
        assets.audio.push({
          src: match[1],
          chapter: chapter.title,
          filename: match[1].split('/').pop()
        });
      }
      
      // Extract document links
      const docRegex = /<a[^>]+href="([^"]+\.(pdf|doc|docx|ppt|pptx))"[^>]*>/gi;
      while ((match = docRegex.exec(chapter.content)) !== null) {
        assets.documents.push({
          src: match[1],
          chapter: chapter.title,
          filename: match[1].split('/').pop(),
          type: match[2]
        });
      }
    }
  });
  
  return assets;
}

/**
 * Generate table of contents for export
 * @param {Array} chapters - Chapter array
 * @returns {Array} - TOC entries
 */
function generateTableOfContents(chapters) {
  if (!chapters || chapters.length === 0) return [];
  
  return chapters.map((chapter, index) => ({
    id: `chapter-${index + 1}`,
    title: chapter.title,
    level: 1,
    page: (index * 10) + 1, // Estimated page numbers
    href: `#chapter-${index + 1}`,
    sections: chapter.sections?.map((section, sectionIndex) => ({
      id: `section-${index + 1}-${sectionIndex + 1}`,
      title: section.title,
      level: 2,
      page: (index * 10) + (sectionIndex + 2),
      href: `#section-${index + 1}-${sectionIndex + 1}`
    })) || []
  }));
}

/**
 * Validate export data before processing
 * @param {object} book - Book object to validate
 * @param {string} format - Export format
 * @returns {object} - Validation result
 */
export function validateExportData(book, format) {
  const errors = [];
  const warnings = [];
  
  // Basic validation
  if (!book) {
    errors.push('Book data is required');
    return { isValid: false, errors, warnings };
  }
  
  if (!book.title || book.title.trim() === '') {
    errors.push('Book title is required');
  }
  
  if (!book.chapters || book.chapters.length === 0) {
    errors.push('At least one chapter is required');
  }
  
  // Format-specific validation
  switch (format) {
    case 'pdf':
      if (book.pages > 500) {
        warnings.push('Large PDF files may take longer to generate');
      }
      break;
      
    case 'docx':
      if (book.wordCount > 50000) {
        warnings.push('Large DOCX files may have compatibility issues');
      }
      break;
      
    case 'epub':
      if (!book.language) {
        warnings.push('Language metadata recommended for EPUB');
      }
      break;
      
    case 'html':
      // Check for external dependencies
      const assets = extractBookAssets(book);
      if (assets.images.length > 20) {
        warnings.push('Many images may increase file size significantly');
      }
      break;
  }
  
  // Content validation
  book.chapters?.forEach((chapter, index) => {
    if (!chapter.title || chapter.title.trim() === '') {
      errors.push(`Chapter ${index + 1} title is required`);
    }
    
    if (!chapter.content || chapter.content.trim() === '') {
      warnings.push(`Chapter ${index + 1} has no content`);
    }
  });
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Generate export filename
 * @param {object} book - Book object
 * @param {string} format - Export format
 * @returns {string} - Generated filename
 */
export function generateExportFilename(book, format) {
  if (!book || !format) return `untitled.${format}`;
  
  // Clean title for filename
  const cleanTitle = book.title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
  
  const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  const version = book.version || '1.0';
  
  return `${cleanTitle}-v${version}-${timestamp}.${format}`;
}

/**
 * Calculate export file size estimate
 * @param {object} book - Book object
 * @param {string} format - Export format
 * @returns {object} - Size estimate
 */
export function estimateExportSize(book, format) {
  if (!book) return { size: 0, unit: 'KB', readable: '0 KB' };
  
  const wordCount = book.wordCount || 0;
  const imageCount = extractBookAssets(book).images.length;
  
  let estimatedBytes = 0;
  
  switch (format) {
    case 'pdf':
      // PDF: ~2KB per page + images
      estimatedBytes = (book.pages || 0) * 2048 + (imageCount * 102400); // 100KB per image
      break;
      
    case 'docx':
      // DOCX: ~1KB per 100 words + images
      estimatedBytes = (wordCount / 100) * 1024 + (imageCount * 51200); // 50KB per image
      break;
      
    case 'epub':
      // EPUB: ~0.5KB per 100 words + images
      estimatedBytes = (wordCount / 100) * 512 + (imageCount * 25600); // 25KB per image
      break;
      
    case 'html':
      // HTML: ~0.3KB per 100 words + images + CSS/JS
      estimatedBytes = (wordCount / 100) * 307 + (imageCount * 51200) + 10240; // +10KB for CSS/JS
      break;
      
    default:
      estimatedBytes = wordCount * 6; // ~6 bytes per word average
  }
  
  // Convert to readable format
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(estimatedBytes) / Math.log(1024));
  const size = parseFloat((estimatedBytes / Math.pow(1024, i)).toFixed(1));
  
  return {
    bytes: estimatedBytes,
    size,
    unit: sizes[i] || 'Bytes',
    readable: `${size} ${sizes[i] || 'Bytes'}`
  };
}

/**
 * Generate export progress tracker
 * @param {object} book - Book object
 * @param {string} format - Export format
 * @returns {object} - Progress tracker configuration
 */
export function createExportProgress(book, format) {
  const steps = [];
  
  // Common steps for all formats
  steps.push(
    { id: 'validate', name: 'Validating content', progress: 0 },
    { id: 'prepare', name: 'Preparing export data', progress: 0 },
    { id: 'process', name: `Generating ${format.toUpperCase()}`, progress: 0 },
    { id: 'finalize', name: 'Finalizing file', progress: 0 },
    { id: 'complete', name: 'Export complete', progress: 0 }
  );
  
  // Format-specific steps
  switch (format) {
    case 'pdf':
      steps.splice(2, 0, 
        { id: 'layout', name: 'Creating page layout', progress: 0 },
        { id: 'render', name: 'Rendering PDF pages', progress: 0 }
      );
      break;
      
    case 'epub':
      steps.splice(2, 0,
        { id: 'package', name: 'Packaging EPUB structure', progress: 0 },
        { id: 'compress', name: 'Compressing EPUB file', progress: 0 }
      );
      break;
      
    case 'html':
      steps.splice(2, 0,
        { id: 'assets', name: 'Processing assets', progress: 0 },
        { id: 'bundle', name: 'Bundling files', progress: 0 }
      );
      break;
  }
  
  return {
    steps,
    currentStep: 0,
    totalSteps: steps.length,
    overallProgress: 0,
    startTime: Date.now(),
    estimatedDuration: calculateEstimatedDuration(book, format)
  };
}

/**
 * Calculate estimated export duration
 * @param {object} book - Book object
 * @param {string} format - Export format
 * @returns {number} - Estimated duration in milliseconds
 */
function calculateEstimatedDuration(book, format) {
  const baseTime = 2000; // 2 seconds base time
  const chapterCount = book.chapters?.length || 0;
  const wordCount = book.wordCount || 0;
  const imageCount = extractBookAssets(book).images.length;
  
  let multiplier = 1;
  
  switch (format) {
    case 'pdf':
      multiplier = 1.5; // PDF generation is slower
      break;
    case 'epub':
      multiplier = 1.2; // EPUB packaging overhead
      break;
    case 'html':
      multiplier = 0.8; // HTML is fastest
      break;
    case 'docx':
      multiplier = 1.0; // Baseline
      break;
  }
  
  const chapterTime = chapterCount * 500; // 500ms per chapter
  const wordTime = Math.floor(wordCount / 1000) * 100; // 100ms per 1000 words
  const imageTime = imageCount * 200; // 200ms per image
  
  return (baseTime + chapterTime + wordTime + imageTime) * multiplier;
}

/**
 * Create export manifest for tracking
 * @param {object} book - Book object
 * @param {string} format - Export format
 * @param {object} options - Export options
 * @returns {object} - Export manifest
 */
export function createExportManifest(book, format, options = {}) {
  const metadata = formatExportMetadata(book, format);
  const sizeEstimate = estimateExportSize(book, format);
  
  return {
    id: generateId('export'),
    bookId: book.id,
    format,
    filename: generateExportFilename(book, format),
    metadata,
    options: {
      includeImages: options.includeImages !== false,
      includeQuestions: options.includeQuestions !== false,
      includeSummaries: options.includeSummaries !== false,
      includeReferences: options.includeReferences !== false,
      pageSize: options.pageSize || 'A4',
      margin: options.margin || 'normal',
      fontSize: options.fontSize || 'normal',
      ...options
    },
    size: sizeEstimate,
    createdAt: new Date().toISOString(),
    status: 'pending',
    progress: createExportProgress(book, format),
    validation: validateExportData(book, format)
  };
}

/**
 * Generate unique ID for exports
 * @param {string} prefix - ID prefix
 * @returns {string} - Unique ID
 */
function generateId(prefix = 'id') {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Export helper for client-side download
 * @param {Blob} blob - File blob
 * @param {string} filename - Download filename
 * @param {string} mimeType - File MIME type
 */
export function downloadFile(blob, filename, mimeType) {
  // Create blob URL
  const url = window.URL.createObjectURL(new Blob([blob], { type: mimeType }));
  
  // Create temporary download link
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  
  // Cleanup
  document.body.removeChild(link);
  window.URL.revokeObjectURL(url);
}

/**
 * Convert book data to different formats (client-side simulation)
 * @param {object} book - Book object
 * @param {string} format - Export format
 * @returns {Promise<string>} - Formatted content
 */
export async function convertBookToFormat(book, format) {
  // Simulate processing time
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  switch (format) {
    case 'pdf':
      return generatePDFContent(book);
    case 'docx':
      return generateDOCXSections(book);
    case 'epub':
      return generateEPUBChapters(book);
    case 'html':
      return generateHTMLStructure(book);
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
}

/**
 * Batch export multiple books
 * @param {Array} books - Array of book objects
 * @param {string} format - Export format
 * @param {object} options - Export options
 * @returns {Promise<Array>} - Array of export results
 */
export async function batchExportBooks(books, format, options = {}) {
  const results = [];
  
  for (const book of books) {
    try {
      const manifest = createExportManifest(book, format, options);
      const content = await convertBookToFormat(book, format);
      
      results.push({
        success: true,
        book: book.title,
        manifest,
        content,
        size: estimateExportSize(book, format)
      });
    } catch (error) {
      results.push({
        success: false,
        book: book.title,
        error: error.message
      });
    }
  }
  
  return results;
}